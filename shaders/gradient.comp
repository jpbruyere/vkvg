#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 3200
#define HEIGHT 2400
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout ( binding = 0, rgba8 ) uniform writeonly image2D buf;

void main() {

  /*
  In order to fit the work into workgroups, some unnecessary threads are launched.
  We terminate those threads here.
  */
  if(gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
	return;

  float x = float(gl_GlobalInvocationID.x) / float(WIDTH);
  float y = float(gl_GlobalInvocationID.y) / float(HEIGHT);

  /*
  What follows is code for rendering the mandelbrot set.
  */
  vec2 uv = vec2(x,y);
  float n = 0.0;
  vec2 c = vec2(-.445, 0.0) +  (uv - 0.5)*(2.0+ 1.7*0.2  ),
  z = vec2(0.0);
  const int M =128;
  for (int i = 0; i<M; i++)
  {
	z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;
	if (dot(z, z) > 2) break;
	n++;
  }

  // we use a simple cosine palette to determine color:
  // http://iquilezles.org/www/articles/palettes/palettes.htm
  float t = float(n) / float(M);
  vec3 d = vec3(0.3, 0.3 ,0.5);
  vec3 e = vec3(-0.2, -0.3 ,-0.5);
  vec3 f = vec3(2.1, 2.0, 3.0);
  vec3 g = vec3(0.0, 0.1, 0.0);
  vec4 color = vec4( d + e*cos( 6.28318*(f*t+g) ) ,1.0);


  imageStore(buf, ivec2(gl_GlobalInvocationID.xy), color);
}
/*
uniform float windowHeight;

uniform vec2  gradientStartPos;
uniform vec2  gradientEndPos;
uniform int   numStops;
uniform vec4  colors[16];
uniform float stops[16];

void main() {

	float  alpha = atan( -gradientEndPos.y + gradientStartPos.y, gradientEndPos.x - gradientStartPos.x );
	float  gradientStartPosRotatedX = gradientStartPos.x*cos(alpha) - gradientStartPos.y*sin(alpha);
	float  gradientEndPosRotatedX   = gradientEndPos.x*cos(alpha) - gradientEndPos.y*sin(alpha);
	float  d = gradientEndPosRotatedX - gradientStartPosRotatedX;


	float y = windowHeight - gl_FragCoord.y;
	float x = gl_FragCoord.x;
	float xLocRotated = x*cos( alpha ) - y*sin( alpha );

	gl_FragColor = mix(colors[0], colors[1], smoothstep( gradientStartPosRotatedX + stops[0]*d, gradientStartPosRotatedX + stops[1]*d, xLocRotated ) );
	for ( int i=1; i<numStops-1; ++i ) {
		gl_FragColor = mix(gl_FragColor, colors[i+1], smoothstep( gradientStartPosRotatedX + stops[i]*d, gradientStartPosRotatedX + stops[i+1]*d, xLocRotated ) );
	}


}*/
